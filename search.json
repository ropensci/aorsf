[{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to aorsf","title":"Contributing to aorsf","text":"Want contribute aorsf? Great! aorsf initially stable state development, great deal active subsequent development envisioned. outline propose change aorsf. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to aorsf","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to aorsf","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to aorsf","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"bcjaeger/aorsf\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to aorsf","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://bcjaeger.github.io/aorsf/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to aorsf","text":"Please note aorsf project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://bcjaeger.github.io/aorsf/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2021 aorsf authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"background-orsf","dir":"Articles","previous_headings":"","what":"Background: ORSF","title":"Introduction to aorsf","text":"oblique random survival forest (ORSF) extension axis-based RSF algorithm can found several R packages, including RandomForestSRC, party, ranger.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"what-is-an-oblique-decision-tree","dir":"Articles","previous_headings":"","what":"What is an oblique decision tree?","title":"Introduction to aorsf","text":"Decision trees developed splitting set training data two new subsets, goal similarity within new subsets . splitting process repeated resulting subsets data stopping criterion met. new subsets data formed based single predictor, decision tree said axis-based splits data appear perpendicular axis predictor. linear combinations variables used instead single variable, tree oblique splits data neither parallel right angle axis. Decision trees classification axis-based splitting (left) oblique splitting (right). Cases orange squares; controls purple circles. trees partition predictor space defined variables X1 X2, oblique splits better job separating two classes.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"accelerated-orsf","dir":"Articles","previous_headings":"","what":"Accelerated ORSF","title":"Introduction to aorsf","text":"purpose aorsf (‘’ short accelerated) provide routines fit ORSFs scale adequately large data sets. example, aorsf::orsf() runs 500 times faster predecessor, obliqueRSF::ORSF(). fit accelerated ORSF model, use orsf function: may notice first input aorsf data_train. design choice makes easier use orsf pipes (.e., %>% |>). instance, addition reputation slow computing, oblique decision trees considered less interpretable axis-based counterparts. opinionated developer aorsf disagrees sentiment, included routines aorsf use coefficients linear combinations input variables estimate variable importance identify pair-wise interactions.","code":"library(aorsf) library(ggplot2)  set.seed(329)  orsf_fit <- orsf(data_train = pbc_orsf,                   formula = Surv(time, status) ~ . - id,                   n_tree = 2500)  orsf_fit #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 2500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>  #> ----------------------------------------- library(dplyr)  orsf_fit <- pbc_orsf |>   select(-id) |>   orsf(formula = Surv(time, status) ~ .)"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"variable-importance","dir":"Articles","previous_headings":"Accelerated ORSF","what":"Variable importance","title":"Introduction to aorsf","text":"aorsf provides multiple ways compute variable importance. compute negation importance, ORSF multiplies coefficient variable -1 re-computes --sample (sometimes referred --bag) accuracy ORSF model.","code":"variable_importance <- orsf_vi_negate(orsf_fit)  variable_importance #>          bili           age       ascites       protime        copper  #>  0.0134923942  0.0085434466  0.0057824547  0.0046363826  0.0037507814  #>       spiders         edema         stage           sex           ast  #>  0.0036465930  0.0028751029  0.0022921442  0.0016670140  0.0012502605  #>        hepato      alk.phos          chol          trig           trt  #> -0.0003125651 -0.0012502605 -0.0017191081 -0.0018232965 -0.0026568035  #>      platelet  #> -0.0028130861"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"partial-dependence","dir":"Articles","previous_headings":"Accelerated ORSF","what":"Partial dependence","title":"Introduction to aorsf","text":"edema == 1 may modify effect bili. can use orsf_pd_summary() function (pd = partial dependence) explore variables influence expected prediction ORSF.  presence edema clearly impacts predicted risk, makes hard see interaction effect plot. Let’s align partial dependence values edema subgroups curve start value 0 aligned partial dependence values can see interaction effect clearly. Increasing bilirubin solicits greater increase predicted risk patients edema (edema == 0), untreated edema (edema == 0.5), successfully treated edema (edema == 0.5) compared patients therapy-resistant edema (edema == 1).  similarity trajectories patients edema == 0 edema == 0.5 suggests edema == 1 strongest modifying effect bilirubin. sanity check, can fit Cox regression model conduct likelihood ratio test interaction: interaction p-value 0.0208 interpreted usual way apriori hypothesis, (used software score every pairwise interaction data picked one strong score). However, nice see interaction identified ORSF’s partial dependence function also identified traditional modeling strategy.","code":"# make a list containing the variable values you # want to compute partial dependence for pd_spec <- list(edema = c(\"0\", \"0.5\", \"1\"),                 bili = seq(0.6, 7.1, by = 0.1))  # orsf_pd_summary automatically computes pd for all combinations # in the list (this can be turned off with expand_grid = FALSE) pd_data <- orsf_pd_summary(object = orsf_fit,                             pd_spec = pd_spec,                            expand_grid = TRUE)  ggplot(pd_data) +  aes(x = bili, y = mean, col = edema) +  geom_line() +   labs(y = 'Predicted risk',       x = 'Bilirubin',       title = 'Partial dependence of bilirubin and edema') # aligning predictions at lowest value of bili min_ed_0 <- with(pd_data, mean[edema == \"0\"   & bili == 0.6]) min_ed_1 <- with(pd_data, mean[edema == \"0.5\" & bili == 0.6]) min_ed_2 <- with(pd_data, mean[edema == \"1\"   & bili == 0.6])  pd_data_aligned <-  within(pd_data, {   value <- mean   value[edema == \"0\" ] <- value[edema == \"0\" ] - min_ed_0   value[edema == \"0.5\"] <- value[edema == \"0.5\"] - min_ed_1   value[edema == \"1\" ] <- value[edema == \"1\" ] - min_ed_2  })  head(pd_data_aligned) #>    edema bili      mean        lwr      medn       upr       value #> 1:     0  0.6 0.2149491 0.01080575 0.1137336 0.7657705 0.000000000 #> 2:   0.5  0.6 0.2741353 0.03608109 0.1817965 0.7841916 0.000000000 #> 3:     1  0.6 0.3871624 0.16876186 0.3089575 0.8766335 0.000000000 #> 4:     0  0.7 0.2164976 0.01087216 0.1138735 0.7712087 0.001548474 #> 5:   0.5  0.7 0.2762397 0.03626453 0.1829204 0.7878749 0.002104399 #> 6:     1  0.7 0.3886400 0.16936039 0.3116935 0.8779078 0.001477504 ggplot(pd_data_aligned) +  aes(x = bili, y = value, col = edema) +  geom_line() +   labs(y = 'Predictions centered at Bilirubin = 0.6',       x = 'Bilirubin',       title = 'Interaction between bilirubin and edema') library(survival)  anova(coxph(Surv(time,status) ~ edema * bili, data = pbc_orsf)) #> Analysis of Deviance Table #>  Cox model: response is Surv(time, status) #> Terms added sequentially (first to last) #>  #>             loglik   Chisq Df Pr(>|Chi|)     #> NULL       -550.19                           #> edema      -524.61 51.1681  2  7.744e-12 *** #> bili       -502.51 44.1953  1  2.972e-11 *** #> edema:bili -498.64  7.7459  2     0.0208 *   #> --- #> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"summarize-orsf-models","dir":"Articles","previous_headings":"Accelerated ORSF","what":"Summarize ORSF models","title":"Introduction to aorsf","text":"Getting straight variable importance partial dependence direct way can often helpful exploratory analyses. want lot information just little code, orsf_summarize_uni() tool :","code":"orsf_summarize_uni(orsf_fit, n_variables = 5) #>  #> -- bili (VI Rank: 1) --------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   0.80 0.2321709 0.1250703 0.04511286 0.3822285 #>   1.40 0.2526454 0.1452361 0.05893072 0.4017982 #>   3.52 0.3716990 0.2879513 0.16520375 0.5483311 #>  #> -- age (VI Rank: 2) ---------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   41.5 0.2738421 0.1429054 0.04190491 0.4670137 #>   49.7 0.3012377 0.1711906 0.04922133 0.5312928 #>   56.6 0.3324703 0.2206562 0.07135028 0.5659502 #>  #> -- ascites (VI Rank: 3) ------------------------ #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>      0 0.2962853 0.1559449 0.04856002 0.5312403 #>      1 0.4707099 0.3853747 0.27346654 0.6542754 #>  #> -- protime (VI Rank: 4) ------------------------ #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   10.0 0.2836244 0.1532223 0.04709130 0.5059426 #>   10.6 0.2956075 0.1611090 0.05140038 0.5249728 #>   11.2 0.3168198 0.1890442 0.06756468 0.5346692 #>  #> -- copper (VI Rank: 5) ------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   42.8 0.2656012 0.1388691 0.04530208 0.4752255 #>   74.0 0.2823505 0.1590903 0.05506762 0.5037839 #>    129 0.3358382 0.2179729 0.10527331 0.5494800 #>  #>  Predicted risk at time t = 1788 for top 5 predictors"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"what-about-the-original-orsf","dir":"Articles","previous_headings":"","what":"What about the original ORSF?","title":"Introduction to aorsf","text":"original ORSF (.e., obliqueRSF) used glmnet find linear combinations inputs. aorsf allows users implement approach using orsf_control_net() function: net forests fit lot faster original ORSF function obliqueRSF. However, net forests still 100 times slower cph ones:","code":"orsf_net <- orsf(data_train = pbc_orsf,                   formula = Surv(time, status) ~ . - id,                   control = orsf_control_net(),                  n_tree = 50) # tracking how long it takes to fit 50 glmnet trees print(  t1 <- system.time(   orsf(data_train = pbc_orsf,         formula = Surv(time, status) ~ . - id,         control = orsf_control_net(),        n_tree = 50)  ) ) #>    user  system elapsed  #>   4.193   0.004   4.198  # and how long it takes to fit 50 cph trees print(  t2 <- system.time(   orsf(data_train = pbc_orsf,         formula = Surv(time, status) ~ . - id,         control = orsf_control_cph(),        n_tree = 50)  ) ) #>    user  system elapsed  #>   0.032   0.000   0.032  t1['elapsed'] / t2['elapsed'] #>  elapsed  #> 131.1875"},{"path":"https://bcjaeger.github.io/aorsf/articles/aorsf.html","id":"aorsf-and-other-machine-learning-software","dir":"Articles","previous_headings":"","what":"aorsf and other machine learning software","title":"Introduction to aorsf","text":"Generally, aorsf follows conventions set R packages randomForest randomForestSRC. example, print method aorsf models similar randomForestSRC models, specification computing variable importance objects returned variable importance functions. Similar randomForestSRC, aorsf allows recommends partial dependence estimated using --bag data. unique feature aorsf fitting oblique random survival forests fast maintaining strong prediction accuracy. RLT obliqueRSF fit oblique random survival forests, aorsf faster. ranger randomForestSRC fit survival forests, neither package supports oblique splitting. obliqueRF fits oblique random forests classification regression, survival. PPforest fits oblique random forests classification survival. default prediction behavior aorsf models produce predicted risk specific prediction horizon, default ranger randomForestSRC.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"out-of-bag-data","dir":"Articles","previous_headings":"","what":"Out-of-bag data","title":"Out-of-bag predictions and evaluation","text":"random forests, tree grown bootstrapped version training set. bootstrap samples selected replacement, bootstrapped training set contains two-thirds instances original training set. ‘--bag’ data instances bootstrapped training set.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"out-of-bag-predictions-and-error","dir":"Articles","previous_headings":"","what":"Out-of-bag predictions and error","title":"Out-of-bag predictions and evaluation","text":"tree random forest can make predictions --bag data, --bag predictions can aggregated make ensemble --bag prediction. Since --bag data used grow tree, accuracy ensemble --bag predictions approximate generalization error random forest. --bag prediction error plays central role routines estimate variable importance, e.g. negation importance. Let’s fit oblique random survival forest plot distribution ensemble --bag predictions.  surprisingly, survival predictions 0 1. Next, let’s check --bag accuracy fit: --bag estimate Harrell’s C-statistic (default method evaluate --bag predictions) 0.84179.","code":"fit <- orsf(data_train = pbc_orsf,              formula = Surv(time, status) ~ . - id,             oobag_time = 3500)  hist(fit$surv_oobag,       main = 'Ensemble out-of-bag survival predictions at t=3,500') # what function is used to evaluate out-of-bag predictions? fit$eval_oobag$stat_type #> [1] \"Harrell's C-statistic\"  # what is the output from this function? fit$eval_oobag$stat_values #>         [,1] #> [1,] 0.84179"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"monitoring-out-of-bag-error","dir":"Articles","previous_headings":"","what":"Monitoring out-of-bag error","title":"Out-of-bag predictions and evaluation","text":"--bag data set contains one-third training set, --bag error estimate usually converges stable value trees added forest. want monitor convergence --bag error oblique random survival forest, can set oobag_eval_every compute --bag error every oobag_eval_every tree. example, let’s compute --bag error fitting tree forest 50 trees:  general, least 500 trees recommended random forest fit. ’re just using 50 case better illustration --bag error curve. Also, helps make run-times low whenever need re-compile package vignettes.","code":"fit <- orsf(data_train = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_time = 3500,             oobag_eval_every = 1)  plot(  x = seq(1, 50, by = 1),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag C-statistic computed after each new tree is grown.',  xlab = 'Number of trees grown',  ylab = fit$eval_oobag$stat_type )"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"user-supplied-out-of-bag-evaluation-functions","dir":"Articles","previous_headings":"","what":"User-supplied out-of-bag evaluation functions","title":"Out-of-bag predictions and evaluation","text":"cases, may want use function compute --bag error. example, simple (incorrect) way compute Brier score. (incorrect account censoring) two ways apply function compute --bag error. First, can apply function --bag survival predictions stored ‘aorsf’ objects, e.g: Second, can pass function orsf(), used place Harrell’s C-statistic:  Let’s run one example showing can done using functions packages, e.g., survivalROC survivalROC package:","code":"oobag_fun_brier <- function(y_mat, s_vec){   # risk = 1 - survival   r_vec <- 1 - s_vec   # mean of the squared differences between predicted and observed risk  mean( (y_mat[, 'status'] - r_vec)^2 )   } oobag_fun_brier(y_mat = fit$data_train[, c('time', 'status')],                 s_vec = fit$surv_oobag) #> [1] 0.1895173 fit <- orsf(data_train = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_time = 3500,             oobag_fun = oobag_fun_brier,             oobag_eval_every = 1)  plot(  x = seq(1, 50, by = 1),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag error computed after each new tree is grown.',  sub = 'For the Brier score, lower values indicate more accurate predictions',  xlab = 'Number of trees grown',  ylab = \"Brier score\" ) oobag_fun_sroc <- function(y_mat, s_vec){   score <- survivalROC::survivalROC(   Stime = y_mat[, 'time'],   status = y_mat[, 'status'],   # risk = 1 - survival   marker = 1 - s_vec,   # important!! Make sure this matches the time you used in orsf   predict.time = 3500,   # nearest neighbor estimation for censoring   method = \"NNE\",   # value taken from ?survivalROC examples   span = 0.25 * nrow(y_mat)^(-0.20)  )    # oobag_fun needs to return a numeric value of length 1  score$AUC  }  fit <- orsf(data_train = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 50,             oobag_time = 3500,             oobag_fun = oobag_fun_sroc,             oobag_eval_every = 1)  plot(  x = seq(50),  y = fit$eval_oobag$stat_values,   main = 'Out-of-bag time-dependent AUC\\ncomputed after each new tree is grown.',  xlab = 'Number of trees grown',  ylab = \"AUC at t = 3,500\" )"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"specific-instructions-on-user-supplied-functions","dir":"Articles","previous_headings":"User-supplied out-of-bag evaluation functions","what":"Specific instructions on user-supplied functions","title":"Out-of-bag predictions and evaluation","text":"User-supplied functions must: exactly two arguments named y_mat s_vec. return numeric output length 1 either conditions true, error occur. simple test make sure user-supplied function work aorsf package :","code":"# Helper code to make sure your oobag_fun function will work with aorsf  # time and status values test_time <- seq(from = 1, to = 5, length.out = 100) test_status <- rep(c(0,1), each = 50)  # y-matrix is presumed to contain time and status (with column names) y_mat <- cbind(time = test_time, status = test_status) # s_vec is presumed to be a vector of survival probabilities s_vec <- seq(0.9, 0.1, length.out = 100)  # see 1 in the checklist above names(formals(oobag_fun_sroc)) == c(\"y_mat\", \"s_vec\") #> [1] TRUE TRUE  test_output <- oobag_fun_sroc(y_mat = y_mat, s_vec = s_vec)  # test output should be numeric is.numeric(test_output) #> [1] TRUE # test_output should be a numeric value of length 1 length(test_output) == 1 #> [1] TRUE"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"user-supplied-functions-for-negation-importance-","dir":"Articles","previous_headings":"","what":"User-supplied functions for negation importance.","title":"Out-of-bag predictions and evaluation","text":"Negation importance based --bag error, course may curious negation importance computed using different statistics. workflow exactly example , except specify importance = 'negate' fit model. Also, speed computations, going monitor --bag error .","code":"fit_sroc <- orsf(data_train = pbc_orsf,                  formula = Surv(time, status) ~ . - id,                  n_tree = 50,                  oobag_time = 3500,                  oobag_fun = oobag_fun_sroc,                  importance = 'negate')  fit_sroc$importance #>       protime           ast      platelet       albumin          bili  #>  5.839253e-02  5.100279e-02  3.364323e-02  2.638768e-02  9.546744e-03  #>          trig         sex_f           age          chol   trt_placebo  #>  8.114727e-03  7.658293e-03  6.572758e-03  6.561591e-03  5.691104e-03  #>     ascites_1     spiders_1     edema_0.5      hepato_1       edema_1  #>  4.054500e-03  1.638046e-05 -1.032562e-04 -8.676532e-04 -6.086700e-03  #>      alk.phos        copper         stage  #> -8.906582e-03 -1.217369e-02 -2.411587e-02"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"multiple-functions-for-negation-importance","dir":"Articles","previous_headings":"User-supplied functions for negation importance.","what":"Multiple functions for negation importance","title":"Out-of-bag predictions and evaluation","text":"’d like compute several types negation importance model, can done using orsf_vi_negate(), allows specify --bag function just orsf() : discrepancies methods ranking important variables. simulation study determine method estimating --bag error better job discriminating important unimportant variables helpful.","code":"fit <- orsf(data_train = pbc_orsf,             formula = Surv(time, status) ~ . - id,             n_tree = 500,             oobag_time = 3500)  # use default technique (harrell's C-statistic) orsf_vi_negate(fit) #>          bili           age           sex       ascites       spiders  #>  0.0167743280  0.0155240675  0.0090643884  0.0075015628  0.0059908314  #>         stage       protime        copper        hepato         edema  #>  0.0057824547  0.0055740779  0.0050531361  0.0043238175  0.0024781949  #>           ast      alk.phos      platelet       albumin           trt  #>  0.0020316733 -0.0001562826 -0.0011460721 -0.0016149198 -0.0022400500  #>          chol          trig  #> -0.0028651802 -0.0039070640  # use C-statistic from survivalROC orsf_vi_negate(fit, oobag_fun = oobag_fun_sroc) #>          bili           sex      alk.phos        hepato          chol  #>  0.0136291908  0.0048503422  0.0041059693 -0.0002998864 -0.0011411051  #>       albumin         edema           ast       spiders       protime  #> -0.0018063939 -0.0045697232 -0.0084033699 -0.0099658322 -0.0114797815  #>          trig       ascites         stage      platelet           trt  #> -0.0119075547 -0.0149055165 -0.0159188892 -0.0195293070 -0.0205513662  #>           age        copper  #> -0.0221462695 -0.0371532096  # you can also use custom functions for permutation importance orsf_vi_permute(fit, oobag_fun = oobag_fun_sroc) #>           ast        hepato      alk.phos         stage          bili  #>  0.0191663088  0.0114149160  0.0074712977  0.0066385069  0.0063662080  #>       albumin          chol         edema       protime      platelet  #>  0.0038332859 -0.0006424132 -0.0025888023 -0.0044149083 -0.0050798739  #>       spiders           sex          trig       ascites           trt  #> -0.0062288275 -0.0080254000 -0.0116633390 -0.0116835328 -0.0131823291  #>           age        copper  #> -0.0139014338 -0.0202554859"},{"path":"https://bcjaeger.github.io/aorsf/articles/oobag.html","id":"i-really-need-to-use","dir":"Articles","previous_headings":"","what":"I really need to use","title":"Out-of-bag predictions and evaluation","text":"can use package whatsoever evaluate --bag predictions. can access final --bag survival predictions aorsf model like : notes remember evaluating --bag error surv_oobag: oobag_time input orsf() determines prediction horizon --bag predictions. prediction horizon critical input evaluation predictions time--event outcomes. functions expect predicted risk (.e., 1 - predicted survival), others expect predicted survival. cases, also able use package whatsoever compute negation importance. One exception point riskRegression. experimented riskRegression found functions work expect try run C++. think may due riskRegression’s internal use data.table modification reference, certainty yet.","code":"surv_oobag <- fit$surv_oobag  surv_oobag[1:5, ] #> [1] 0.01407141 0.41328693 0.21373385 0.24695800 0.30650363"},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"background-partial-dependence","dir":"Articles","previous_headings":"","what":"Background: Partial dependence","title":"Compute partial dependence with ORSF","text":"Partial dependence plots show average marginal effect combination features imparts predicted risk. Individual conditional expectation plots narrow focus individual datapoints.","code":""},{"path":"https://bcjaeger.github.io/aorsf/articles/pd.html","id":"getting-partial-dependance-from-an-aorsf-object","dir":"Articles","previous_headings":"","what":"Getting partial dependance from an aorsf object","title":"Compute partial dependence with ORSF","text":"First fit accelerated ORSF model pbc_orsf, modification Mayo Clinic Primary Biliary Cholangitis data: view partial dependence predicted risk combination blood vessel malformations skin (spiders) urine copper (copper), use orsf_pd_summary. pd_spec argument contains variable values want compute partial dependence . default oobag == TRUE, meaning partial dependence calculated using bag training data. keep set TRUE computing partial dependence using training data. expand_grid == TRUE tells orsf_pd_summary use combinations values pd_spec.  Next lets look Individual Conditional Expectation (ICE). instance dataset represented one line showing change prediction dependent change feature. orsf_pd_ice allows use multiple features, recommended view one time. plot can see data point’s predicted survival changes copper changes.","code":"set.seed(123)  orsf_fit <- orsf(data_train = pbc_orsf,                  formula = Surv(time, status) ~ . -id,                  n_tree = 2500) pd_spec <- list(spiders = c(\"0\", \"1\"),                 copper = seq(45, 130, by = 10))  pd_data <- orsf_pd_summary(object = orsf_fit,                            pd_spec = pd_spec,                            oobag = TRUE,                            expand_grid = TRUE)  ggplot(pd_data) +  aes(x = copper, y = mean, col = spiders) +  geom_line() +   labs(y = 'Predicted risk',       x = 'Urine Copper',       title = 'Partial dependence of copper and spiders') ice_data <- orsf_pd_ice(object = orsf_fit,                        pd_spec = list(copper = seq(45, 130, by = 10)),                        expand_grid = TRUE)  ggplot(ice_data[id_row %in% c(1:30)]) +  aes(x=copper, y=pred, group=id_row) +  geom_line() +  labs(y = 'Predicted risk',      x = 'Urine Copper',      title = 'Individual conditional expectation of copper',      subtitle = 'Data for 30 patients are shown')"},{"path":"https://bcjaeger.github.io/aorsf/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Byron Jaeger. Author, maintainer. Nicholas Pajewski. Contributor. Sawyer Welden. Contributor.","code":""},{"path":"https://bcjaeger.github.io/aorsf/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Byron C. Jaeger, D. Leann Long, Dustin M. Long, Mario Sims, Jeff M. Szychowski, Yuan-Min, Leslie . Mcclure, George Howard, Noah Simon (2019). Oblique Random Survival Forests. Ann. Appl. Stat. 13(3): 1847-1883. URL https://doi.org/10.1214/19-AOAS1261 DOI: 10.1214/19-AOAS1261","code":"@Article{,   title = {Oblique Random Survival Forests},   author = {Byron C. Jaeger and D. Leann Long and Dustin M. Long and Mario Sims and Jeff M. Szychowski and Yuan-I Min and Leslie A. Mcclure and George Howard and Noah Simon},   journal = {Annals of Applied Statistics},   year = {2019},   volume = {13},   number = {3},   pages = {1847--1883},   url = {https://doi.org/10.1214/19-AOAS1261}, }"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"aorsf-","dir":"","previous_headings":"","what":"Accelerated Oblique Random Survival Forests","title":"Accelerated Oblique Random Survival Forests","text":"aorsf provides optimized software fit, interpret, make predictions oblique random survival forests (ORSFs).","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"why-aorsf","dir":"","previous_headings":"","what":"Why aorsf?","title":"Accelerated Oblique Random Survival Forests","text":"400 times faster obliqueRSF. accurate predictions time--event outcomes. negation importance, novel technique estimate variable importance ORSFs. intuitive API formula based interface. extensive input checks + informative error messages.","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Accelerated Oblique Random Survival Forests","text":"can install development version aorsf GitHub :","code":"# install.packages(\"remotes\") remotes::install_github(\"bcjaeger/aorsf\")"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Accelerated Oblique Random Survival Forests","text":"orsf() function used fit ORSFs. Printing output orsf() give descriptive statistics ensemble. interpreting fit? use orsf_vi_negate() orsf_vi_anova() variable importance use orsf_pd_ice() orsf_pd_summary() individual aggregated partial dependence values. use orsf_summarize_uni() show top predictor variables ORSF model expected predicted risk specific values predictors. (term ‘uni’ short univariate.)","code":"library(aorsf)  fit <- orsf(data_train = pbc_orsf,             formula = Surv(time, status) ~ . - id)  print(fit) #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>  #> ----------------------------------------- orsf_vi_negate(fit) #>          bili           age       protime       ascites       albumin  #>  0.0129714524  0.0125026047  0.0085955407  0.0063554907  0.0061992082  #>       spiders           sex        copper         edema           ast  #>  0.0057303605  0.0049489477  0.0044280058  0.0027783566  0.0018753907  #>        hepato          trig         stage      alk.phos      platelet  #>  0.0018232965  0.0016670140  0.0005209419 -0.0006772244 -0.0008856012  #>          chol           trt  #> -0.0016670140 -0.0025526151 orsf_pd_summary(fit, pd_spec = list(bili = c(1:5))) #>    bili      mean        lwr      medn       upr #> 1:    1 0.2376652 0.01286480 0.1331328 0.8669733 #> 2:    2 0.2904995 0.04154464 0.1889294 0.8943053 #> 3:    3 0.3441193 0.06285072 0.2538335 0.9146453 #> 4:    4 0.3973732 0.10091026 0.3247072 0.9271855 #> 5:    5 0.4424865 0.14005297 0.3807676 0.9315099 # take a look at the top 5 variables  # for continuous predictors, see expected risk at 25/50/75th quantile # for categorical predictors, see expected risk in specified category  orsf_summarize_uni(object = fit, n_variables = 5) #>  #> -- bili (VI Rank: 1) --------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   0.80 0.2337275 0.1267164 0.04190426 0.3716894 #>   1.40 0.2526511 0.1452163 0.05476829 0.3998048 #>   3.52 0.3730196 0.2841226 0.16033444 0.5673070 #>  #> -- age (VI Rank: 2) ---------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   41.5 0.2736650 0.1332843 0.04270990 0.4575449 #>   49.7 0.2993351 0.1656678 0.04910598 0.5203980 #>   56.6 0.3314766 0.2113831 0.06956163 0.5472662 #>  #> -- protime (VI Rank: 3) ------------------------ #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   10.0 0.2815397 0.1430703 0.04704506 0.4987604 #>   10.6 0.2947893 0.1526181 0.05252053 0.5393637 #>   11.2 0.3176024 0.1831842 0.06925762 0.5566000 #>  #> -- ascites (VI Rank: 4) ------------------------ #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>      0 0.2954662 0.1462719 0.04778412 0.5409697 #>      1 0.4597940 0.3742798 0.25999819 0.6551916 #>  #> -- albumin (VI Rank: 5) ------------------------ #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   3.31 0.3176012 0.1789175 0.05525473 0.5785138 #>   3.54 0.2934144 0.1527704 0.04236004 0.5225606 #>   3.77 0.2791547 0.1412617 0.04199867 0.4937002 #>  #>  Predicted risk at time t = 1788 for top 5 predictors"},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Accelerated Oblique Random Survival Forests","text":"Byron C. Jaeger, D. Leann Long, Dustin M. Long, Mario Sims, Jeff M. Szychowski, Yuan-Min, Leslie . Mcclure, George Howard, Noah Simon (2019). Oblique Random Survival Forests. Ann. Appl. Stat. 13(3): 1847-1883. URL https://doi.org/10.1214/19-AOAS1261 DOI: 10.1214/19-AOAS1261","code":""},{"path":"https://bcjaeger.github.io/aorsf/index.html","id":"funding","dir":"","previous_headings":"","what":"Funding","title":"Accelerated Oblique Random Survival Forests","text":"developers aorsf receive financial support Center Biomedical Informatics, Wake Forest University School Medicine. also receive support National Center Advancing Translational Sciences National Institutes Health Award Number UL1TR001420. content solely responsibility authors necessarily represent official views National Institutes Health.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/aorsf-package.html","id":null,"dir":"Reference","previous_headings":"","what":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","title":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","text":"Fit, interpret, make predictions oblique random survival forests. Oblique decision trees notoriously slow compared axis based counterparts, 'aorsf' runs fast faster axis-based decision tree algorithms right-censored time--event outcomes.","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/aorsf-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"aorsf: Accelerated Oblique Random Survival Forests — aorsf-package","text":"Maintainer: Byron Jaeger bjaeger@wakehealth.edu (ORCID) contributors: Nicholas Pajewski [contributor] Sawyer Welden swelden@wakehealth.edu [contributor]","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Oblique Random Survival Forest (ORSF) — orsf","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Oblique Random Survival Forest (ORSF)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"","code":"orsf(   data_train,   formula,   control = orsf_control_cph(),   n_tree = 500,   n_split = 5,   n_retry = 3,   mtry = NULL,   leaf_min_events = 1,   leaf_min_obs = 5,   split_min_events = 5,   split_min_obs = 10,   split_min_stat = 3.841459,   oobag_pred = TRUE,   oobag_time = NULL,   oobag_eval_every = n_tree,   oobag_fun = NULL,   importance = \"anova\",   tree_seeds = NULL,   attach_data = TRUE,   no_fit = FALSE )  orsf_train(object)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"data_train (data.frame) used grow forest. formula (formula) formula object, response left ~ operator, terms right (see details). Variables right hand size ~ can numeric, integer, factor variables. Factors may ordered unordered. control aorsf_control object, created orsf_control_net orsf_control_cph. Default control = orsf_control_cph(). n_tree (integer) number trees grow. Default n_tree = 500. n_split (integer) number cut-points assessed splitting node decision trees. Default n_split = 5. n_retry (integer) node can split, current linear combination inputs unable provide valid split, orsf try new linear combination based different set randomly selected predictors, n_retry pred_horizon. n_retry = 0 retry mechanic applied. Default n_retry = 3. mtry (integer) Number variables randomly selected candidates splitting node. default smallest integer greater square root number features, .e., mtry = ceiling(sqrt(number predictors)) leaf_min_events (integer) minimum number events leaf node. Default leaf_min_events = 1 leaf_min_obs (integer) minimum number observations leaf node. Default leaf_min_obs = 5 split_min_events (integer) minimum number events required split node. Default split_min_events = 5 split_min_obs (integer) minimum number observations required split node. Default split_min_obs = 10. split_min_stat (double) minimum test statistic required split node. Default 3.841459 log-rank test, roughly p-value 0.05 oobag_pred (logical) TRUE --bag predictions returned aorsf object. Default TRUE. oobag_time (numeric) numeric value indicating time used --bag predictions. Default median observed pred_horizon, .e., oobag_time = median(time). oobag_eval_every (integer) --bag performance ensemble checked every oobag_eval_every trees. , oobag_eval_every = 10, --bag performance checked growing 10th tree, 20th tree, . Default oobag_eval_every = n_tree, --bag performance assessed growing trees. oobag_fun (function) oobag_fun = NULL (default), --bag predictions evaluated using Harrell's C-statistic. value oobag_fun provided, used place Harrell's C-statistic evaluate --bag predictions. function must two inputs: y_mat s_vec. input y_mat presumed matrix two columns named time (first column) status (second column). input s_vec presumed numeric vector containing predicted survival probabilities y_mat. importance (character) Indicate method variable importance: 'none': variable importance computed. 'anova': use analysis variance (ANOVA) method 'negate': compute negation importance 'permute': compute permutation importance See details descriptions available methods. Note oobag_fun specified , used computation negation importance permutation importance, role ANOVA importance. tree_seeds (integer vector) specified, random seeds set using values tree_seeds[]  growing tree . Two forests grown number trees seeds exact --bag samples , many cases, random sets candidate predictors. design makes comparisons --bag error two random forests meaningful, since --bag performance random forest depends somewhat observations picked --bag samples. tree_seeds NULL (default), seeds set training process. attach_data (logical) TRUE, copy training data attached output. helpful plan using functions like orsf_pd_summary interpret fitted forest using training data. Default TRUE. no_fit (logical) TRUE, pre-processing steps defined parametrized, training initiated. object returned can directly submitted orsf_train() long attach_data TRUE. object untrained aorsf object, created setting no_fit = TRUE orsf().","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"accelerated oblique RSF object (aorsf)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"function based highly similar ORSF function obliqueRSF R package. primary difference function runs much faster. speed increase attributable better management memory (.e., unnecessary copies inputs) using Newton Raphson scoring algorithm identify linear combinations inputs rather performing penalized regression using routines glmnet.modified Newton Raphson scoring algorithm function applies adaptation C++ routine developed Terry M. Therneau fits Cox proportional hazards models (see survival::coxph() specifically survival::coxph.fit()). comments inputs formula: response formula can survival object returned survival::Surv function, can also just time status variables. example, Surv(time, status) ~ . works just like time + status ~ .. thing can break input putting variables wrong order, .e., writing status + time ~ . make orsf assume status variable actually time variable. mtry: mtry parameter may temporarily reduced ensure least 2 events per predictor variable. occurs using orsf_control_cph coefficients Newton Raphson scoring algorithm may become unstable number covariates greater equal number events. reduction occur using orsf_control_net.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"Breiman L. Random forests. Machine learning. 2001 Oct;45(1):5-32. DOI: 10.1023/:1010933404324 Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests. Annals applied statistics. 2008 Sep;2(3):841-60. DOI: 10.1214/08-AOAS169 Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min YI, Mcclure LA, Howard G, Simon N. Oblique random survival forests. Annals applied statistics. 2019 Sep;13(3):1847-83. DOI: 10.1214/19-AOAS1261 Harrell FE, Califf RM, Pryor DB, Lee KL, Rosati RA. Evaluating Yield Medical Tests. JAMA. 1982;247(18):2543–2546. DOI: 10.1001/jama.1982.03320430047030","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Oblique Random Survival Forest (ORSF) — orsf","text":"","code":"# standard workflow for model development: fit and interpret  fit <- orsf(pbc_orsf, formula = Surv(time, status) ~ . - id)  print(fit) #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>  #> -----------------------------------------  # more specific parameters  fit_custom <- orsf(pbc_orsf,                    formula = time + status ~ . - id,                    mtry = 2,                    oobag_time = 4000,                    oobag_eval_every = 50)  # 10 oobag error values are computed  b/c oob error # is assessed every 50 trees (50, 100, ..., 500) fit_custom$eval_oobag$stat_values #>            [,1] #>  [1,] 0.8235049 #>  [2,] 0.8348093 #>  [3,] 0.8388206 #>  [4,] 0.8398625 #>  [5,] 0.8398625 #>  [6,] 0.8368410 #>  [7,] 0.8379350 #>  [8,] 0.8369452 #>  [9,] 0.8364763 #> [10,] 0.8361117  # make your own oobag function: # (this is an R implementation of Harrell's C # stat, which is what orsf uses by default)  oobag_c_harrell <- function(y_mat, s_vec){  time = y_mat[, 1]  status = y_mat[, 2]  events = which(status == 1)  k = nrow(y_mat)  total <- 0  concordant <- 0  for(i in events){   if(i+1 <= k){    for(j in seq(i+1, k)){     if(time[j] > time[i]){      total <- total + 1      if(s_vec[j] > s_vec[i]){       concordant <- concordant + 1      } else if (s_vec[j] == s_vec[i]){       concordant <- concordant + 0.5      }     }    }   }  }  concordant / total }  # tree_seeds lets you grow each tree with the seed it corresponds to # (nice way to make sure my R oobag function gives the same answer # as the internal C oobag function)  fit_custom_oobag <- orsf(pbc_orsf,                          formula = Surv(time, status) ~ . - id,                          oobag_fun = oobag_c_harrell,                          n_tree = 10,                          tree_seeds = 1:10)  fit_standard_oobag <- orsf(pbc_orsf,                            formula = Surv(time, status) ~ . - id,                            n_tree = 10,                            tree_seeds = 1:10)  fit_standard_oobag$eval_oobag$stat_values #>           [,1] #> [1,] 0.7689102  fit_custom_oobag$eval_oobag$stat_values #>           [,1] #> [1,] 0.7689102"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox proportional hazards control — orsf_control_cph","title":"Cox proportional hazards control — orsf_control_cph","text":"Cox proportional hazards control","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox proportional hazards control — orsf_control_cph","text":"","code":"orsf_control_cph(method = \"efron\", eps = 1e-09, iter_max = 1, do_scale = TRUE)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox proportional hazards control — orsf_control_cph","text":"method (character) character string specifying method tie handling. ties, methods equivalent. Valid options 'breslow' 'efron'. Efron approximation default accurate dealing tied event times similar computational efficiency compared Breslow method. eps (double) using Newton Raphson scoring identify linear combinations inputs, iteration continues algorithm relative change  log partial likelihood less eps, absolute change less sqrt(eps). Must positive. default value 1e-09 used consistency survival::coxph.control. iter_max (integer) using Newton Raphson scoring identify linear combinations inputs, iteration continues convergence (see eps ) number attempted iterations equal iter_max. default value 1 used computational efficiency. do_scale (logical) TRUE, values predictors scaled prior running Newton Raphson scoring. Setting FALSE reduce computation time also make regression unstable, default value TRUE. stability, orsf let set input FALSE also set iter_max 1.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cox proportional hazards control — orsf_control_cph","text":"object class 'aorsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cox proportional hazards control — orsf_control_cph","text":"Therneau T.M., Grambsch P.M. (2000) Cox Model. : Modeling Survival Data: Extending Cox Model. Statistics Biology Health. Springer, New York, NY. DOI: 10.1007/978-1-4757-3294-8_3","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_cph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cox proportional hazards control — orsf_control_cph","text":"","code":"orsf(data_train = pbc_orsf,      formula = Surv(time, status) ~ . - id,      control = orsf_control_cph()) #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 500 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.84 #>            OOB stat type: Harrell's C-statistic #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom control of oblique decision trees — orsf_control_custom","title":"Custom control of oblique decision trees — orsf_control_custom","text":"Custom control oblique decision trees","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom control of oblique decision trees — orsf_control_custom","text":"","code":"orsf_control_custom(beta_fun)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom control of oblique decision trees — orsf_control_custom","text":"beta_fun (function) function define coefficients used linear combinations predictor variables. beta_fun must accept three inputs named x_node, y_node w_node, expect following types dimensions: x_node (matrix; n rows, p columns) y_node (matrix; n rows, 2 columns) w_node (matrix; n rows, 1 column) addition, beta_fun must return matrix p rows 1 column. conditions met, orsf_control_custom() let know.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom control of oblique decision trees — orsf_control_custom","text":"object class 'aorsf_control', used input control argument orsf.","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_custom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom control of oblique decision trees — orsf_control_custom","text":"","code":"# fit an oblique random survival forest using random coefficients to # generate linear combinations of predictor variables. First, define # a function that supplies the random coefficients:  f <- function(x_node, y_node, w_node) { matrix(runif(ncol(x_node)), ncol=1) }  # next, plug the function into orsf_control_custom(), which is in turn # passed into orsf():  fit_rando <- orsf(pbc_orsf,                   Surv(time, status) ~ .,                   control = orsf_control_custom(beta_fun = f),                   n_tree = 500)  # last, check the out-of-bag performance. # it's surprising how well the random approach works.  fit_rando$eval_oobag #> $stat_values #>           [,1] #> [1,] 0.7833924 #>  #> $stat_type #> [1] \"Harrell's C-statistic\" #>"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":null,"dir":"Reference","previous_headings":"","what":"Elastic net control — orsf_control_net","title":"Elastic net control — orsf_control_net","text":"Elastic net control","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Elastic net control — orsf_control_net","text":"","code":"orsf_control_net(alpha = 1/2, df_target = NULL)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Elastic net control — orsf_control_net","text":"alpha elastic net mixing parameter. value 1 gives lasso penalty, value 0 gives ridge penalty. multiple values alpha given, penalized model fit using alpha value prior splitting node. df_target Preferred number variables used linear combination. Note: less mtry, separate argument orsf indicates number variables chosen random prior finding linear combination variables.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Elastic net control — orsf_control_net","text":"object class 'aorsf_control', used input control argument orsf.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Elastic net control — orsf_control_net","text":"Simon N, Friedman J, Hastie T, Tibshirani R. Regularization paths Cox’s proportional hazards model via coordinate descent. Journal statistical software. 2011 Mar;39(5):1. DOI: 10.18637/jss.v039.i05","code":""},{"path":[]},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_control_net.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Elastic net control — orsf_control_net","text":"","code":"# orsf_control_net() is considerably slower than orsf_control_cph(), # The example uses n_tree = 25 so that my examples run faster, # but you should use at least 500 trees in applied settings.  orsf(data_train = pbc_orsf,      formula = Surv(time, status) ~ . - id,      n_tree = 25,      control = orsf_control_net()) #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 25 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 24 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.56 #>            OOB stat type: Harrell's C-statistic #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF partial dependence — orsf_pd_summary","title":"ORSF partial dependence — orsf_pd_summary","text":"ORSF partial dependence","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF partial dependence — orsf_pd_summary","text":"","code":"orsf_pd_summary(   object,   pd_data = NULL,   pd_spec,   pred_horizon = NULL,   expand_grid = TRUE,   prob_values = c(0.025, 0.5, 0.975),   prob_labels = c(\"lwr\", \"medn\", \"upr\"),   oobag = TRUE,   risk = TRUE,   boundary_checks = TRUE )  orsf_pd_ice(   object,   pd_data = NULL,   pd_spec,   pred_horizon = NULL,   expand_grid = TRUE,   oobag = TRUE,   risk = TRUE,   boundary_checks = TRUE )"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF partial dependence — orsf_pd_summary","text":"object (aorsf) accelerated oblique random survival forest model. pd_data (data frame) used compute partial dependence. NULL, training data object used. training data attached object (see attach_data input orsf), error triggered. @srrstats G2.1a explicit secondary documentation expectations data types vector inputs pd_spec (named list data.frame). pd_spec named list, item list vector values used points partial dependence function. name item list indicate variable modified take corresponding values. pd_spec data.frame, columns indicate variable names, values indicate variable values, partial dependence computed using inputs row. pred_horizon (double) single time vector times indicating prediction horizon. Predicted risk survival values indicate probability event surviving baseline prediction horizon, respectively. pred_horizon values must exceed maximum follow-time object's training data. Also, pred_horizon values must entered ascending order. expand_grid (logical) TRUE, partial dependence computed possible combinations inputs pd_spec. FALSE, partial dependence computed variable pd_spec, separately. prob_values (numeric) vector values 0 1, indicating quantiles used summarize partial dependence values set inputs. prob_values length prob_labels. prob_labels (character) vector labels length prob_values, label indicating corresponding value prob_values labelled summarized outputs. prob_labels length prob_values. oobag (logical) TRUE, partial dependence computed using bag training data. set oobag = TRUE computing partial dependence using training data object. risk (logical) TRUE, predicted risk returned. FALSE, predicted survival (.e., 1-risk) returned. boundary_checks (logical) TRUE, pd_spec vetted make sure requested values 10th 90th percentile object's training data. FALSE, checks skipped.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF partial dependence — orsf_pd_summary","text":"data.table containing summarized partial dependence values using orsf_pd_summery individual conditional expectation (ICE) partial dependence using orsf_pd_ice.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_pd_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF partial dependence — orsf_pd_summary","text":"","code":"fit <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  orsf_pd_summary(fit, pd_spec = list(bili = c(1,2,3,4,5,6)), pred_horizon = 1000) #>    bili      mean         lwr       medn       upr #> 1:    1 0.1377902 0.003330241 0.05430434 0.7627931 #> 2:    2 0.1646638 0.012987037 0.08226932 0.7861936 #> 3:    3 0.2035382 0.030230071 0.12019997 0.8117641 #> 4:    4 0.2298192 0.044165295 0.15187044 0.8233694 #> 5:    5 0.2542596 0.059329923 0.18003407 0.8317105 #> 6:    6 0.2781497 0.087177175 0.20892540 0.8465930  # more points for a plot pd_spec <- list(bili = seq(1, 6, length.out = 20)) data_ice <- orsf_pd_ice(fit, pd_spec = pd_spec, pred_horizon = c(1000))  head(data_ice) #>    id_variable id_row bili        pred #> 1:           1      1    1 0.777159353 #> 2:           1      2    1 0.035357619 #> 3:           1      3    1 0.367434601 #> 4:           1      4    1 0.183776714 #> 5:           1      5    1 0.049666465 #> 6:           1      6    1 0.006585182  library(ggplot2)  ggplot(data_ice) +  aes(x = bili, y = pred, group = id_row) +  geom_line(alpha = 0.4, color = 'grey') +  geom_smooth(aes(group = 1), color = 'black', se = FALSE) +  theme_bw() +  theme(panel.grid = element_blank()) #> `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale input data — orsf_scale_cph","title":"Scale input data — orsf_scale_cph","text":"functions exported users may access internal routines used scale inputs orsf_control_cph used.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale input data — orsf_scale_cph","text":"","code":"orsf_scale_cph(x_mat, w_vec = NULL)  orsf_unscale_cph(x_mat)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale input data — orsf_scale_cph","text":"x_mat (numeric matrix) matrix values scaled unscaled. Note orsf_unscale_cph accept x_mat inputs attribute containing transform values, added automatically orsf_scale_cph. w_vec (numeric vector) optional vector weights. weights supplied (default), observations equally weighted. supplied, w_vec must length equal nrow(x_mat).","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale input data — orsf_scale_cph","text":"scaled unscaled x_mat.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scale input data — orsf_scale_cph","text":"data transformed first subtracting mean multiplying scale. inverse transform can completed using orsf_unscale_cph dividing column corresponding scale adding mean. values means scales stored attribute output returned orsf_scale_cph (see examples)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_scale_cph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale input data — orsf_scale_cph","text":"","code":"x_mat <- as.matrix(pbc_orsf[, c('bili', 'age', 'protime')])  head(x_mat) #>   bili      age protime #> 1 14.5 58.76523    12.2 #> 2  1.1 56.44627    10.6 #> 3  1.4 70.07255    12.0 #> 4  1.8 54.74059    10.3 #> 5  3.4 38.10541    10.9 #> 7  1.0 55.53457     9.7  x_scaled <- orsf_scale_cph(x_mat)  head(x_scaled) #>             bili        age    protime #> [1,]  3.77308887  1.0412574  1.9694656 #> [2,] -0.75476469  0.7719344 -0.1822316 #> [3,] -0.65339483  2.3544852  1.7005035 #> [4,] -0.51823502  0.5738373 -0.5856748 #> [5,]  0.02240421 -1.3581657  0.2212116 #> [6,] -0.78855464  0.6660494 -1.3925613  attributes(x_scaled) # note the transforms attribute #> $dim #> [1] 276   3 #>  #> $dimnames #> $dimnames[[1]] #> NULL #>  #> $dimnames[[2]] #> [1] \"bili\"    \"age\"     \"protime\" #>  #>  #> $transforms #>           mean     scale #> [1,]  3.333696 0.3378995 #> [2,] 49.799661 0.1161396 #> [3,] 10.735507 1.3448108 #>   x_unscaled <- orsf_unscale_cph(x_scaled)  head(x_unscaled) #>      bili      age protime #> [1,] 14.5 58.76523    12.2 #> [2,]  1.1 56.44627    10.6 #> [3,]  1.4 70.07255    12.0 #> [4,]  1.8 54.74059    10.3 #> [5,]  3.4 38.10541    10.9 #> [6,]  1.0 55.53457     9.7  # numeric difference in x_mat and x_unscaled should be practically 0 max(abs(x_mat - x_unscaled)) #> [1] 8.881784e-16"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF summary of univariate information — orsf_summarize_uni","title":"ORSF summary of univariate information — orsf_summarize_uni","text":"ORSF summary univariate information","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF summary of univariate information — orsf_summarize_uni","text":"","code":"orsf_summarize_uni(   object,   n_variables = NULL,   pred_horizon = NULL,   risk = TRUE,   importance_type = \"negate\" )"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF summary of univariate information — orsf_summarize_uni","text":"object (aorsf) oblique random survival forest (ORSF; see orsf). n_variables (integer) many variables summarized? Setting input lower number improve computation time. pred_horizon (double) single time vector times indicating prediction horizon. Predicted risk survival values indicate probability event surviving baseline prediction horizon, respectively. pred_horizon values must exceed maximum follow-time object's training data. Also, pred_horizon values must entered ascending order. risk (logical) TRUE, predicted risk returned. FALSE, predicted survival (.e., 1-risk) returned. importance_type (character) method use variable importance. Valid input values 'anova' 'negate'. See orsf_vi_negate details methods.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF summary of univariate information — orsf_summarize_uni","text":"object class 'aorsf_summary'","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_summarize_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF summary of univariate information — orsf_summarize_uni","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  orsf_summarize_uni(object, n_variables = 3) #>  #> -- bili (VI Rank: 1) --------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   0.80 0.2328986 0.1208788 0.04197891 0.3821871 #>   1.40 0.2533109 0.1407947 0.05661284 0.4004234 #>   3.52 0.3739967 0.2883141 0.16687306 0.5502153 #>  #> -- age (VI Rank: 2) ---------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   41.5 0.2712569 0.1318444 0.04171728 0.4507432 #>   49.7 0.2991625 0.1653623 0.04985479 0.5320268 #>   56.6 0.3319486 0.2114678 0.06875796 0.5773699 #>  #> -- copper (VI Rank: 3) ------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   42.8 0.2638577 0.1320068 0.04498940 0.4625747 #>   74.0 0.2805345 0.1498672 0.05663613 0.4780401 #>    129 0.3371588 0.2214657 0.10477683 0.5409297 #>  #>  Predicted risk at time t = 1788 for top 3 predictors"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate training time — orsf_time_to_train","title":"Estimate training time — orsf_time_to_train","text":"Estimate training time","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate training time — orsf_time_to_train","text":"","code":"orsf_time_to_train(object, n_tree_subset = 50)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate training time — orsf_time_to_train","text":"object untrained aorsf object n_tree_subset (integer)  many trees fit order estimate time needed train object. default value 50, usually gives good enough approximation.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate training time — orsf_time_to_train","text":"difftime object.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_time_to_train.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate training time — orsf_time_to_train","text":"","code":"# specify but do not train the model by setting no_fit = TRUE. object <- orsf(pbc_orsf, Surv(time, status) ~ . - id,                n_tree = 500, no_fit = TRUE)  # grow 50 trees to approximate the time it will take to grow 500 trees time_estimated <- orsf_time_to_train(object, n_tree_subset = 50)  print(time_estimated) #> Time difference of 0.5828054 secs  # let's see how close the approximation was time_true_start <- Sys.time() fit <- orsf_train(object) time_true_stop <- Sys.time()  time_true <- time_true_stop - time_true_start  print(time_true) #> Time difference of 0.5199878 secs  # error abs(time_true - time_estimated) #> Time difference of 0.06281757 secs"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF variable importance — orsf_vi_negate","title":"ORSF variable importance — orsf_vi_negate","text":"Determine importance individual variables using 'negation importance.' See 'Details' definition negation importance.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF variable importance — orsf_vi_negate","text":"","code":"orsf_vi_negate(object, group_factors = TRUE, oobag_fun = NULL)  orsf_vi_permute(object, group_factors = TRUE, oobag_fun = NULL)  orsf_vi_anova(object, group_factors = TRUE)"},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF variable importance — orsf_vi_negate","text":"object object class 'aorsf'. group_factors (logical) TRUE, importance factor variables reported overall aggregating importance individual levels factor. FALSE, importance individual factor levels returned. oobag_fun (function) oobag_fun = NULL (default), --bag predictions evaluated using Harrell's C-statistic. value oobag_fun provided, used place Harrell's C-statistic evaluate --bag predictions. function must two inputs: y_mat s_vec. input y_mat presumed matrix two columns named time (first column) status (second column). input s_vec presumed numeric vector containing predicted survival probabilities y_mat.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF variable importance — orsf_vi_negate","text":"named vector. Names indicate predictors, values indicate importance. vector sorted highest lowest value, higher values indicating higher importance.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ORSF variable importance — orsf_vi_negate","text":"negation importance: variable assessed separately multiplying variable's coefficients -1 determining much model's performance changes. worse model's performance negating coefficients given variable, important variable. ANOVA importance: ANOVA importance computes p-value coefficient linear combination variables decision tree oRF. Following definition proposed Menze et al, ANOVA importance aorsf individual variable proportion times p-value coefficient < 0.10. Disclaimer: Negation importance currently development routine may tweaked future updates. ANOVA importance published Menze et al. stable lifecycle negation importance.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ORSF variable importance — orsf_vi_negate","text":"Menze, Bjoern H., et al. oblique random forests. Joint European Conference Machine Learning Knowledge Discovery Databases. Springer, Berlin, Heidelberg, 2011. DOI: 10.1007/978-3-642-23783-6_29","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/orsf_vi_negate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF variable importance — orsf_vi_negate","text":"","code":"fit <- orsf(pbc_orsf,             Surv(time, status) ~ . - id,             oobag_pred = TRUE)  orsf_vi_negate(fit) #>           age          bili       protime         stage       ascites  #>  0.0113565326  0.0110439675  0.0068764326  0.0056782663  0.0053136070  #>       spiders           sex         edema           ast      platelet  #>  0.0035944989  0.0021879558  0.0016161601  0.0009897895  0.0001562826  #>        hepato       albumin          trig           trt      alk.phos  #> -0.0001562826 -0.0023442384 -0.0026047093 -0.0032298395 -0.0037507814  #>          chol  #> -0.0039070640  orsf_vi_anova(fit) #>    ascites       bili      edema     copper        age    albumin    protime  #> 0.36987223 0.28448501 0.23649617 0.19401800 0.17599793 0.16719661 0.15372340  #>      stage    spiders       chol        sex        ast     hepato       trig  #> 0.14249790 0.13524338 0.12939666 0.12557645 0.11760084 0.11001590 0.10121667  #>   alk.phos   platelet        trt  #> 0.09942738 0.07102419 0.06187845"},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"data light modification survival::pbc data. modifications :","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"","code":"pbc_orsf"},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"data frame 276 rows 20 variables: id case number time number days registration earlier death, transplantion, study analysis July, 1986 status status endpoint, 0 censored transplant, 1 dead trt randomized treatment group: D-penicillmain placebo age years sex m/f ascites presence ascites hepato presence hepatomegaly enlarged liver spiders blood vessel malformations skin edema 0 edema, 0.5 untreated successfully treated, 1 edema despite diuretic therapy bili serum bilirunbin (mg/dl) chol serum cholesterol (mg/dl) albumin serum albumin (g/dl) copper urine copper (ug/day) alk.phos alkaline phosphotase (U/liter) ast aspartate aminotransferase, called SGOT (U/ml) trig triglycerides (mg/dl) platelet platelet count protime standardised blood clotting time stage histologic stage disease (needs biopsy)","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"T Therneau P Grambsch (2000), Modeling Survival Data: Extending Cox Model, Springer-Verlag, New York. ISBN: 0-387-98784-3.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/pbc_orsf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mayo Clinic Primary Biliary Cholangitis Data — pbc_orsf","text":"removed rows missing data converted status 0 censor transplant, 1 dead converted stage ordered factor. converted trt, ascites, hepato, spiders, edema factors.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.aorsf.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict risk or survival — predict.aorsf","title":"Predict risk or survival — predict.aorsf","text":"Predict risk survival","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.aorsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict risk or survival — predict.aorsf","text":"","code":"# S3 method for aorsf predict(object, new_data, pred_horizon, risk = TRUE, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.aorsf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict risk or survival — predict.aorsf","text":"object (aorsf) oblique random survival forest (ORSF; see orsf). new_data (data.frame) data compute predictions . Must columns equivalent types data used train object. Also, factors new_data must levels data used train object. Last, missing data supported. pred_horizon (double) single time vector times indicating prediction horizon. Predicted risk survival values indicate probability event surviving baseline prediction horizon, respectively. pred_horizon values must exceed maximum follow-time object's training data. Also, pred_horizon values must entered ascending order. risk (logical) TRUE, predicted risk returned. FALSE, predicted survival (.e., 1-risk) returned. ... used.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.aorsf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict risk or survival — predict.aorsf","text":"matrix predictions. Column j matrix corresponds value j pred_horizon. Row matrix corresponds row new_data.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/predict.aorsf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict risk or survival — predict.aorsf","text":"","code":"#' @srrstats {ML1.1} using the terms 'train' and 'test'.  # indices of data used for training the model train <- seq(1, nrow(pbc_orsf), by = 2)  # indices of data used to test the trained model. test <- seq(2, nrow(pbc_orsf), by = 2)  fit <- orsf(pbc_orsf[train, ], Surv(time, status) ~ . - id)  preds <- predict(fit,                  new_data = pbc_orsf[test, ],                  pred_horizon = c(500, 1500, 2500))  head(preds) #>             [,1]       [,2]       [,3] #> [1,] 0.050698867 0.14309139 0.32425770 #> [2,] 0.183928215 0.44997291 0.60857061 #> [3,] 0.016638423 0.08242184 0.25234884 #> [4,] 0.062903618 0.20632148 0.41115671 #> [5,] 0.070931364 0.13338904 0.25059393 #> [6,] 0.009498547 0.01503642 0.08946871"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf.html","id":null,"dir":"Reference","previous_headings":"","what":"ORSF presentation — print.aorsf","title":"ORSF presentation — print.aorsf","text":"ORSF presentation","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ORSF presentation — print.aorsf","text":"","code":"# S3 method for aorsf print(x, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ORSF presentation — print.aorsf","text":"x object class 'aorsf' ... used","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ORSF presentation — print.aorsf","text":"nothing - just print output console","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ORSF presentation — print.aorsf","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id, n_tree = 5)  print(object) #> ---------- Oblique random survival forest #>  #>           N observations: 276 #>                 N events: 111 #>                  N trees: 5 #>       N predictors total: 17 #>    N predictors per node: 5 #>  Average leaves per tree: 23 #> Min observations in leaf: 5 #>       Min events in leaf: 1 #>           OOB stat value: 0.71 #>            OOB stat type: Harrell's C-statistic #>  #> -----------------------------------------"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf_summary_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"Print ORSF summary — print.aorsf_summary_uni","title":"Print ORSF summary — print.aorsf_summary_uni","text":"Print ORSF summary","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf_summary_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print ORSF summary — print.aorsf_summary_uni","text":"","code":"# S3 method for aorsf_summary_uni print(x, n_variables = NULL, ...)"},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf_summary_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print ORSF summary — print.aorsf_summary_uni","text":"x object class 'aorsf_summary' n_variables number variables print ... used","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf_summary_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print ORSF summary — print.aorsf_summary_uni","text":"nothing - output printed console.","code":""},{"path":"https://bcjaeger.github.io/aorsf/reference/print.aorsf_summary_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print ORSF summary — print.aorsf_summary_uni","text":"","code":"object <- orsf(pbc_orsf, Surv(time, status) ~ . - id)  smry <- orsf_summarize_uni(object, n_variables = 3)  print(smry) #>  #> -- bili (VI Rank: 1) --------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   0.80 0.2366072 0.1204687 0.04226350 0.3794430 #>   1.40 0.2566570 0.1486182 0.05766203 0.4135699 #>   3.52 0.3774792 0.2865221 0.17208670 0.5684324 #>  #> -- age (VI Rank: 2) ---------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>   41.5 0.2757099 0.1476703 0.03983298 0.4669044 #>   49.7 0.3019875 0.1713035 0.04563012 0.5161650 #>   56.6 0.3323675 0.2177966 0.06339960 0.5642084 #>  #> -- sex (VI Rank: 3) ---------------------------- #>  #>        |---------------- risk ----------------| #>  Value      Mean    Median     25th %    75th % #>      m 0.3630937 0.2545164 0.12420987 0.5923374 #>      f 0.2969928 0.1529285 0.04412198 0.5253030 #>  #>  Predicted risk at time t = 1788 for top 3 predictors"},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-0009000","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.0.9000","title":"aorsf 0.0.0.9000","text":"Core features implemented: fit, interpret, predict using oblique random survival forests. Vignettes + Readme covering usage core features. Website hosted GitHub pages, managed pkgdown.","code":""},{"path":"https://bcjaeger.github.io/aorsf/news/index.html","id":"aorsf-001","dir":"Changelog","previous_headings":"","what":"aorsf 0.0.1","title":"aorsf 0.0.1","text":"Added orsf_control_custom(), allows users submit custom functions identifying linear combinations inputs growing oblique decision trees. filled ROpenSci review continues","code":""}]
